,directlink,paragraf
1,https://id.wikipedia.org/wiki/Algoritma,"Dalam matematika dan ilmu komputer, algoritme adalah prosedur langkah-demi-langkah untuk penghitungan.Algoritme digunakan untuk penghitungan, pemrosesan data, dan penalaran otomatis.Algoritme adalah metode efektif diekspresikan sebagai rangkaian terbatas[1]dari instruksi-instruksi yang telah didefinisikan dengan baik[2]untuk menghitung sebuah fungsi.[3]Dimulai dari sebuah kondisi awal dan input awal (mungkin kosong),[4]instruksi-instruksi tersebut menjelaskan sebuah komputasi yang, bila dieksekusi, diproses lewat sejumlah urutan kondisi terbatas[5]yang terdefinisi dengan baik, yang pada akhirnya menghasilkan ""keluaran""[6]dan berhenti di kondisi akhir.Transisi dari satu kondisi ke kondisi selanjutnya tidak harus deterministik;beberapa algoritme, dikenal dengan algoritme pengacakan, menggunakan masukan acak.[7]Walaupun algorism-nya al-Khawarizmi dirujuk sebagai aturan-aturan melakukan aritmetika menggunakan bilangan Hindu-Arab dan solusi sistematis dan persamaan kuadrat, sebagian formalisasi yang nantinya menjadi algoritme modern dimulai dengan usaha untuk memecahkan permasalahan keputusan (Entscheidungsproblem) yang diajukan oleh David Hilbert pada tahun 1928.Formalisasi selanjutnya dilihat sebagai usaha untuk menentukan ""penghitungan efektif""[8]atau ""metode efektif"";[9]formalisasi tersebut mengikutkan Godel-Herbrand-Kleene fungsi rekursif-nya Kurt Godel - Jacques Herbrand - Stephen Cole Kleene pada tahun 1930, 1934, dan 1935, kalkulus lambda-nya Alonzo Church pada tahun 1936, ""Formulasi 1""-nya Emil Post pada tahun 1936, dan Mesin Turing-nya Alan Turing pada tahun 1936-7 dan 1939.Dari definisi formal dari algoritme di atas, berkaitan dengan konsep intuituf, masih tetap ada masalah yang menantang.[10]'Algoritme' muncul dari 'Algoritmi', bentuk Latin dari al-Khwarizmi, matematikawan, ahli astronomi, dan ahli geografi dari Persia.[11][12]Definisi informalnya bisa berarti ""sekumpulan aturan yang secara tepat menentukan seurutan operasi"".[13]yang mengikutkan semua program komputer, termasuk program yang tidak melakukan perhitungan numerik.Secara umum, sebuah program hanyalah sebuah algoritme jika ia akan berhenti nantinya.[14]Sebuah contoh prototipikal dari suatu algoritme adalah algoritme Euclid untuk menentukan bilangan pembagi terbesar dari dua integer; sebagai contohnya (ada contoh yang lain) dijelaskan dengan diagram alur di atas dan sebagai contoh di bagian lanjut.(Boolos & Jeffrey 1974, 1999) memberikan sebuah makna informal dari kata algoritme dalam persamaan berikut:Tidak ada manusia yang dapat menulis begitu cepat, atau begitu lama, atau begitu kecil (""kecil, dan lebih kecil tanpa batas ... anda mungkin mencoba menulis di atas molekul, atom, elektron"") untuk mencatat semua anggota dari kumpulan bilangan tak terbatas dengan menuliskan namanya, bergantian, dalam suatu notasi.Tapi manusia bisa melakukan sesuatu yang sama bergunanya, pada kasus kumpulan bilangan tak terbatas: Mereka dapat memberikan instruksi jelas untuk menentukan anggota ke-n dari set, untuk n terbatas acak.Instruksi tersebut diberikan secara eksplisit, dalam bentuk yang dapat diikuti oleh mesin penghitung, atau oleh manusia yang mampu melakukan hanya operasi-operasi dasar dengan simbol-simbol.[15]Suatu ""bilangan tak-terbatas"" adalah bilangan yang elemen-elemenya bisa berkorespondensi satu-ke-satu dengan integer.Maka, Boolos dan Jeffrey mengatakan bahwa sebuah algoritme berarti instruksi bagi sebuah proses yang ""membuat"" keluaran integer dari sebuah ""masukan"" acak integer yang, secara teori, bisa sangat besar.Maka sebuah algoritme dapat berupa persamaan aljabar seperti y = m + n -- dua variabel masukan m dan n yang menghasikan keluaran y.Tapi berbagai penulis yang mencoba mendefinisikan persamaan tersebut mengatakan bahwa kata algoritme mengandung lebih dari itu, sesuatu yang kurang lebih (untuk contoh penjumlahan):Konsep dari algoritme juga digunakan untuk mendefinisikan notasi dari desidabilitas.Notasi tersebut adalah pusat untuk menjelaskan bagaimana sistem formal berasal dari sejumlah kecil aksioma dan aturan.Dalam logika, waktu dari sebuah algoritme untuk selesai tidak dapat dihitung, karena tidak berelasi dengan dimensi fisik kita.Dari ketidakpastian tersebut, yang mengkarakteristikan pekerjaan yang sedang berjalan, timbulah ketidak-tersediannya definisi algoritme yang sesuai dengan konkret (pada tingkat tertentu) dan penggunaan secara abstrak dari istilah tersebut.Algoritme sangat penting bagi cara komputer mengolah data.Banyak program komputer mengandung algoritme memberikan rincian pada instruksi khusus yang komputer harus lakukan (dengan urutan tertentu) untuk menjalankan pekerjaan tertentu, seperti menghitung gaji karyawan atau mencetak kartu rapor siswa.Maka, sebuah algoritme bisa dianggap sebagai urutan operasi yang bisa disimulasikan oleh sebuah sistem Turing-lengkap.Penulis yang mendukung tesis ini termasuk Minsky (1967), Savage (1987), dan Gurevich (2000):Minsky: ""Tapi kita juga menjaga, dengan Turing ... bahwa setiap prosedur yang ""secara alami"" disebut efektif, bisa dinyatakan oleh mesin (sederhana).Walaupun tampaknya ekstrem, alasan tersebut ... sukar disanggah"".[21]Gurevich: ""... argumen informal Turing untuk menyokong tesis ini membenarkan tesis yang lebih kuat: setiap algoritme bisa disimulasikan oleh sebuah mesin Turing ... menurut Savage [1987], sebuah algoritme adalah sebuah proses penghitungan yang ditentukan oleh sebuah mesin Turing"".[22]Biasanya, bila sebuah algoritme dihubungkan dengan pengolahan informasi, data dibaca dari sumber masukan, ditulis ke perangkat keluaran, dan/atau disimpan untuk pengolahan selanjutnya.Data simpanan dianggap sebagai bagian dari keadaan internal dari entitas yang melakukan algoritme.Pada praktiknya, keadaan tersebut disimpan pada satu atau lebih struktur data.Untuk beberapa proses komputasi, algoritme harus ditentukan secara teliti: dijabarkan dengan cara ia bakal berlaku untuk semua kemungkinan yang dapat timbul.Yaitu, setiap langkah tambahan harus secara sistematis dihadapi, kasus-per-kasus;Kriteria bagi setiap kasus harus jelas (dan bisa dihitung).Karena sebuah algoritme adalah kumpulan dari langkah-langkah yang tepat, urutan dari komputasi selalu penting bagi berfungsinya algoritme.Instruksi biasanya diasumsikan terdaftar secara eksplisit, dan dijelaskan dimulai ""dari atas"" dan terus ""ke bawah"", sebuah gambaran yang dijelaskan secara formal oleh alur kontrolSejauh ini, diskusi tentang formalisasi algoritme telah mengasumsikan premis dari pemrograman imperatif.Hal ini merupakan konsepsi umum, yang mencoba menjelaskan sebuah pekerjaan dalam makna diskrit dan ""mekanis"".Keunikan dari konsepsi formalisasi algoritme adalah operasi penetapan, mengatur nilai dari sebuah variabel.Ia berasal dari intuisi ""ingatan"" sebagai kertas buram.Contoh operasi penetapan tersebut ada di bawah.Untuk konsepsi yang lain dari apa yang membentuk sebuah algoritme lihat pemrograman fungsional dan pemrograman logika.Algoritme dapat digambarkan dengan banyak notasi, termasuk bahasa alamiah, pseudokode, diagram alur, bagan drakon, bahasa pemrograman atau tabel kontrol (diproses oleh penerjemah).Ekspresi bahasa alamiah terhadap algoritme condong lebih banyak dan rancu, dan jarang digunakan untuk algoritme yang kompleks dan teknis.Pseudokode, diagram alur, bagan drakon, dan tabel kontrol adalah cara yang terstruktur untuk menggambarkan algoritme yang mencegah banyaknya kerancuan pada pernyataan-pernyataan bahasa alamiah.Bahasa pemrograman ditujukan untuk mengekspresikan algoritme dalam sebuah bentuk yang dapat dieksekusi oleh komputer, tetapi sering kali digunakan sebagai suatu cara untuk menentukan atau mendokumentasikan algoritme.Ada banyak macam kemungkinan representasi dan seseorang dapat mengekspresikan sebuah program mesin Turing sebagai urutan dari tabel-tabel mesin (lihat lebih lanjut di mesin kondisi-terbatas, tabel transisi kondisi dan tabel kontrol), sebagai diagram alur dan bagan drakon (lihat lebih lanjut di diagram kondisi), atau sebagai bentuk kode mesin atau kode assembly dasar yang dikenal ""kumpulan lipat empat"" (lihat lebih lanjut di mesin Turing).Representasi dari algoritme dapat dikelompokan ke dalam tiga tingkatan dari deskripsi mesin Turing:[23]Sebagai contoh dari algoritme sederhana ""Penjumlahan m+n"" dijelaskan dalam tiga tingkatan tersebut lihat contoh algoritme.Kebanyakan algoritme ditujukan untuk diimplementasikan sebagai program komputer.Namun, algoritme juga diimplementasikan dengan tujuan lain, seperti dalam jaringan saraf biologis (sebagai contohnya, otak manusia yang mengimplementasikan aritmetika atau sebuah serangga yang melihat makanan), dalam sirkuit elektris, atau dalam sebuah perangkat mekanis.Dalam sistem komputer, sebuah algoritme pada dasarnya adalah instansi dari logika ditulis dalam perangkat lunak oleh pengembang perangkat lunak supaya efektif untuk komputer yang ""ditargetkan"" untuk mesin tertentu untuk menghasilkan keluaran dari masukan yang diberikan (kemungkinan nul).Program yang ""elegan"" (padat), program yang ""baik"" (cepat): Pernyataan dari ""sederhana dan elegan"" muncul secara informal dalam buku Knuth dan dalam Chaitin:Chaitin membuka definisinya dengan: ""Saya akan perlihatkan bahwa anda tidak dapat membuktikan sebuah program adalah 'elegan'""???bukti tersebut akan menyelesaikan permasalahan perhentian (ibid).Algoritme terhadap fungsi yang dapat dihitung oleh algoritme: Untuk sebuah fungsi bisa ada beberapa algoritme.Hal ini benar, bahkan tanpa mengembangkan kumpulan instruksi yang ada bagi programmer.Rogers mengamati bahwa ""Sangat ... penting untuk membedakan antara pengertian algoritme, misalnya prosedur dan pernyataan fungsi yang dihitung oleh algoritme, misalnya pemetaan hasil dari prosedur.Fungsi yang sama bisa memiliki beberapa algoritme berbeda"".[26]Sayangnya ada pertukaran antara kebaikan (kecepatan) dan elegan (kepadatan) -- sebuah program yang elegan bisa melakukan lebih banyak langkah untuk menyelesaikan sebuah komputasi daripada yang kurang elegan.Sebuah contoh yang menggunakan algoritme Euclid bisa dilihat di bawah.Komputer (dan komputor), model dari komputasi: Sebuah komputer (atau manusia ""komputor""[27])adalah tipe terbatas dari mesin, sebuah ""perangkat mekanis deterministik diskrit""[28]yang secara buta mengikuti instruksinya[29].Model primitif dari Melzak dan Lambek[30]mereduksi pemikiran tersebut menjadi empat elemen: (i) diskrit, lokasi yang bisa dibedakan,(ii) diskrit, penghitung yang tak bisa dibedakan[31](iii) sebuah agen, dan(iv) sebuah daftar instruksi yang efektif relatif terhadap kemampuan dari agen.[32]Minsky menjelaskan variasi yang lebih sesuai dari model ""abacus""-nya Lambek dalam ""Basis Komputabilitas Paling Sederhana"".[33]Mesin Minsky memproses secara berurutan lewat lima (atau enam tergantung bagaimana seseorang menghitungnya) instruksi kecuali baik sebuah kondisi IF-THEN GOTO atau GOTO tak bersyarat mengubah alur program keluar dari urutan.Selain HALT, mesin Minsky mengikutkan tiga operasi penetapan (penggantian, substitusi):[34]ZERO (misalnya, isi dari lokasi diganti oleh 0: L ??? 0), SUCCESSOR (misalnya, L ??? L+1), dan DECREMENT (misalnya, L ??? L-1).[35]Jarang seorang programer harus menulis ""kode"" dengan kumpulan instruksi terbatas.Tapi Minsky memperlihatkan (sebagaimana Melzak dan Lambek) bahwa mesinnya adalah Turing komplet dengan hanya empat tipe instruksi utama: GOTO kondisional, GOTO tak bersyarat, penetapan/penggantian/substitusi, dan HALT.[36]Simulasi dari sebuah algoritme: bahasa komputer (komputor): Knuth menganjurkan pembaca bahwa ""cara terbaik untuk belajar algoritme dalah mencobanya ... langsung ambil pulpen dan kertas dan bekerja lewat contoh"".[37]Lalu bagaimana dengan simulasi atau eksekusi yang sebenarnya?Programmer harus menerjemahkan algoritme ke dalam bahasa yang mana simulator/komputer/komputor dapat mengeksekusi secara efektif.Stone memberikan contoh dari hal ini: saat menghitung akar dari persamaan kuadrat si komputor harus tahu bagaimana mendapatkan akar kuadrat.Jika tidak maka supaya algoritme dapat efektif ia harus menyediakan sejumlah aturan untuk mengekstrak akar kuadrat.[38]Hal ini berarti programer harus tahu sebuah ""bahasa"" yang efektif relatif terhadap target pada agen komputasi (komputer/komputor).Lalu model apa yang seharusnya digunakan untuk simulasi?Van Emde Boas mengamati ""bahkan bila kita mendasari teori kompleksitas dengan mesin abstrak bukannya mesin kongkrit, kesembarangan dari pemilihan model masih tetap ada.Pada titik itulah mulainya pemikiran simulasi"".[39]Bila kecepatan yang dihitung, jumlah instruksi berpengaruh.Sebagai contohnya, subprogram dalam algoritme Euclid untuk menghitung sisa akan berjalan lebih cepat jika programmer memiliki instruksi ""modulus"" (sisa pembagian) bukannya dengan pengurangan (atau lebih parah: hanya ""penurunan"").Pemrograman terstuktur, struktur kanonikal: Menurut Tesis Church-Turing setiap algoritme bisa dihitung dengan sebuah model yang dikenal Turing komplet, dan menurut demonstrasi Minsky kekomplitan Turing membutuhkan hanya empat tipe instruksi???GOTO bersyarat, GOTO tak bersyarat, penetapan, HALT.Kemeny dan Kurtz mengamati bahwa saat penggunaan GOTO tak bersyarat yang ""tak disiplin"" dan IF-THEN GOTO bersyarat bisa menghasilkan ""kode spageti"" seorang programer bisa menulis program terstruktur menggunakan instruksi tersebut;di lain sisi ""juga memungkinkan, dan tidak begitu sulit, untuk menulis sebuah program terstruktur yang buruk dalam sebuah bahasa terstruktur"".[40]Tausworthe menambahkan tiga struktur kanon Bohm-Jacopini:[41]SEQUENCE, IF-THEN-ELSE, dan WHILE-DO, dengan dua lagi: DO-WHILE dan CASE.[42]Keuntungan dari program terstruktur adalah ia cocok dengan pembuktian kebenaran menggunakan induksi matematika.[43]Simbol diagram alur[44]: Pembantu grafik yang disebut diagram alur memberikan suatu cara untuk menjelaskan dan mendokumentasikan sebuah algoritme (dan program komputer).Seperti alur program dari mesin Minsky, sebuah diagram alur selalu mulai dari atas dan terus ke bawah.Simbol utamanya hanya 4: arah panah memperlihatkan alur program, segi empat (SEQUENCE, GOTO), wajik (IF-THEN-ELSE), dan titik (OR).Struktur kanonikal Bohm-Jacopini dibuat dari bentuk-bentuk primitif tersebut.Sub-struktur bisa ""bersarang"" dalam segi empat hanya jika jalan keluar tunggal terjadi pada super-struktur.Simbol dan penggunaannya untuk membangun struktur kanonikal diperlihatkan dalam diagram.Salah satu dari algoritme sederhana adalah menemukan bilangan terbesar dalam sebuah deretan angka (tak berurut).Solusinya membutuhkan pemeriksaan setiap angka dalam deret, tetapi hanya sekali.Dari hal ini munculah algoritme sederhana, yang bisa dinyatakan dalam kalimat bahasa deskripsi tingkat-tinggi, sebagai:Deskripsi tingkat-tinggi:Deskripsi (Quasi-)formal:Ditulis dalam kalimat yang lebih dekat dengan bahasa tingkat-tinggi dari program komputer, berikut ini adalah kode formal dari algoritme dalam pseudokode atau kode pijin:Algoritme Euclid muncul sebagai Proposisi II dalam Book VII (""Elementary Number Theory"") dari Elements.[45]Euclid mengajukan permasalahan: ""Ambil dua angka bukan prima, untuk mencari bilangan pembagi terbesar"".Dia menentukan ""Sebuah angka [merupakan] besaran yang terdiri dari unit-unit"": angka penghitung, integer positif kecuali 0.Dan ""mengukur"" adalah menempatkan ukuran panjang terkecil s dengan tepat (q kali) di antara ukuran terpanjang l sampai sisa r lebih kecil dari panjang terkecil s.[46]Dalam dunia modern, sisa r = l - q*s, q sebagai hasil bagi, atau sisa r adalah ""modulus"", bagian sisa-integer yang tersisa setelah pembagian.[47]Supaya metode Euclid berhasil, panjang awalnya harus memenuhi dua kebutuhan:(i) panjangnya tidak 0, DAN(ii) hasil pengurangan harus ""lebih"", sebuah pengujian harus menjamin bahwa bilangan terkecil dari dua angka adalah hasil pengurangan dari yang terbesar (cara lain, keduanya bisa sama sehingga pengurangan menghasilkan 0).Pembuktian asli Euclid mengikutkan kebutuhan yang ketiga: kedua panjang bukanlah bilangan prima.Euclid menentukan hal ini supaya dia bisa membentuk sebuah bukti reductio ad absurdum bahwa dua pembagi dua angka adalah yang terbesar.[48]Walau algoritme Nicomachus sama dengan Euclid, bila kedua bilangan prima maka menghasilkan angka ""1"" untuk bilangan pembagi terbesar.Jadi untuk lebih jelasnya algoritme berikut adalah algoritme Nicomachus.Hanya beberapa tipe instruksi yang dibutuhkan untuk mengeksekusi algoritme???beberapa tes logika (GOTO bersyarat), GOTO tak bersyarat, penetapan (penggantian), dan pengurangan.Algoritme berikut disebut sebagai versi Euclid dan Nichomachus 4-langkah-nya Knuth, tetapi bukannya menggunakan pembagi untuk menentukan sisa ia menggunakan pengurangan berturut-turut dari panjang terkecil s dari sisa panjang r sampai r kurang dari s.Deskripsi tingkat-tinggi, diperlihatkan dengan tulisan tebal, diadaptasi dari Knuth 1973:2-4:INPUT:E0: [Pastikan r ??? s.] E1: [Cari sisa]: Sampai sisa panjang r di R kurang dari panjang terkecil s pada S, kurangi angka s dalam S berulang kali dari sisa panjang r dalam R.E2: [Apakah sisa 0?]: APAKAH (i) pengukuran terakhir adalah sama dan sisa di R adalah 0 program dapat berhenti, ATAU (ii) algoritme harus terus jalan: hasil pengukuran meninggalkan sisa di R kurang dari angka pengukuran dalam S.E3: [Interchange s dan r]: Sulitnya algoritme Euclid. Menggunakan sisa r untuk mengukur angka terkecil sebelumnya s:; L sebagai lokasi sementara.OUTPUT:DONE:Versi algoritme Euclid berikut hanya membutuhkan 6 instruksi inti untuk melakukan 13 langkah pada solusi ""inelegan""; parahnya, ""inelegan"" membutuhkan tipe instruksi lebih banyak.Diagram alur dari ""elegan"" bisa dilihat pada bagian atas artikel ini.Dalam bahasa Basic (tak terstruktur) langkahnya diberi nomor, dan instruksi LET [] = [] adalah instruksi penetapan disimbolkan dengan ???.Bagaimana cara kerja ""Elegan"": Sebagai pengganti ""pengulangan Euclid"" luar, ""Elegan"" mengulang antara dua pengulangan, pengulangan A > B yang menghitung A ??? A - B, dan pengualang B ??? A yang menghitung B ??? B - A.Hal ini bekerja karena, saat yang dikurang M lebih kecil pengurang S ( Selisih = pengurang - yang_di_kurang ), yang_dikurang bisa menjadi s (panjang pengukuran yang baru) dan pengurang bisa menjadi r yang baru (panjang yang akan diukur);dengan kata lain ""arti"" dari pengurangan dibalik.Apakah algoritme berjalan seperti yang penulis inginkan?Beberapa kasus uji cukup menentukan fungsi inti.Sumber pertama[49]menggunakan 3009 dan 884.Knuth menyarankan 40902, 24140.Kasus menarik lainnya yaitu dua angka relatif prima 14157 dan 5950.Tapi kasus pengecualian harus teridentifikasi dan diuji.Apakah ""inelegan"" berjalan benar saat R > S, S > R, R = S?Sama juga dengan ""Elegan"": B > A, A > B, A = B?(Semuanya benar).Apa yang terjadi bila salah satu bilangan nol, atau keduanya nol?(""Inelegan"" terus berjalan pada kedua kasus; ""elegan"" terus berjalan saat A = 0.)Apa yang terjadi bila angka negatif dimasukan?Angka desimal?Bila angka masukan, misalnya domain dari fungsi yang dihitung oleh algoritme/program, mengikutkan hanya integer positif termasuk 0, maka kegagalan pada nol mengindikasikan bahwa algoritme (dan program instansiasinya) adalah sebuah fungsi parsial bukannya fungsi total.Kesalahan yang terkenal karena eksepsi adalah kegagalan roket Ariane V.Bukti dari kebenaran program menggunakan induksi matematika: Knuth mendemonstrasikan penggunaan induksi matematika untuk versi ""pengembangan"" dari algoritme Euclid, dan dia mengajukan ""metode umum yang digunakan untuk membuktikan validitas dari setiap algoritme.""[50]Tausworthe mengajukan bahwa sebuah pengukuran dari kompleksitas dari sebuah program adalah panjang dari pembuktian kebenarannya.[51]Elegan (kepadatan) lawan kebaikan (kecepatan): Dengan hanya 6 instruksi dasar, ""Elegan"" adalah jelas pemenang dibandingkan dengan instruksi ""inelegan"" dengan 13 instruksi.Namun, ""inelegan"" lebih cepat (ia sampai pada HALT dengan langkah lebih sedikit).Analisis algoritme[52]mengindikasikan kenapa hal tersebut terjadi: ""Elegan"" melakukan pengujian kondisi dua kali disetiap pengulangan pengurangan, sementara ""inelegan"" hanya sekali.Bila algoritme (biasanya) membutuhkan banyak pengulangan, secara rata-rata lebih banyak waktu yang terbuang saat melakukan tes ""B = 0?"" yang hanya diperlukan saat sisa sudah dihitung.Bisakah algoritme ditingkatkan?: Bila programmer sudah menilai sebuah program ""cocok"" dan ""efektif""???yaitu, ia menghitung fungsi yang ditujukan oleh penulisnya???maka pertanyaannya menjadi, bisakah ditingkatkan?Kepadatan dari ""inelegan"" bisa ditingkatkan dengan menghilangkan 5 langkah.Tapi Chaitin membuktikan bahwa memadatkan algoritme tidak bisa diotomatiskan dengan algoritme generalisasi;[53]tapi, ia bisa dilakukan secara heuristik, misalnya dengan pencarian menyeluruh (contohnya bisa ditemukan di Berang sibuk), coba dan gagal, kecerdasan, kedalaman, penggunaan penalaran induktif, dll.Bisa diamati bahwa langkah 4, 5, dan 6 diulang pada langkah 11, 12, dan 13.Pembandingan dengan ""Elegan"" menyediakan petunjuk langkah-langkah tersebut dengan langkah 2 dan 3 dapat dihilangkan.Hal ini mereduksi jumlah instruksi dasar dari 13 menjadi 8, yang membuatnya ""lebih elegan"" dari ""Elegan"" dengan 9 langkah.Kecepatan ""Elegan"" bisa ditingkatkan dengan memindahkan tes B=0? keluar dari pengulangan.Perubahan ini memerlukan penambahan 3 instruksi (B=0?, A=0?, GOTO).Sekarang ""Elegant"" menghitung contoh-angka lebih cepat;untuk setiap angka pada A, B dan R, S hal ini selalu merupakan kasus yang membutuhkan analisis yang mendalam.Sangat penting untuk mengetahui berapa banyak sumber tertentu (seperti waktu dan tempat penyimpanan) secara teoretis diperlukan untuk sebuah algoritme.Metode-metode telah dikembangkan untuk analisis algoritme untuk mendapatkan jawaban kuantitatif (estimasi);sebagai contohnya, algoritme pengurutan di atas memerlukan waktu O(n), menggunakan notasi O besar dengan n sebagai panjang deret (yang akan diurut).Setiap saat algoritme hanya perlu mengingat dua nilai: nilai terbesar yang ditemukan, dan posisinya sekarang dideretan input.Oleh karena itu dikatakan memiliki kebutuhan ruang O(1), jika ruang yang dibutuhkan untuk menyimpan angka masukan tidak dihitung, atau O(n) jika dihitung.Algoritme berbeda mungkin menyelesaikan pekerjaan yang sama dengan kumpulan instruksi yang berbeda dengan waktu, ruang, atau 'usaha' lebih sedikit atau banyak dari yang lain.Sebagai contohnya, algoritme pencairan binari biasanya mengungguli pencarian berderet secara paksa bila digunakan untuk tabel pencarian pada deret terurut.Analisis dan kajian algoritme adalah bidang dari ilmu komputer, dan biasanya dilakukan secara abstrak tanpa menggunakan bahasa pemrograman tertentu atau implementasi.Dalam artian, analisis algoritme mirip dengan bidang matematika lainnya yang mana fokus pada properti yang mendasari algoritme dan bukan pada implementasi tertentu.Biasanya pseudokode digunakan pada analisis karena merupakan representasi paling umum dan sederhana.Namun, pada akhirnya, kebanyakan algoritme diimplementasikan di perangkat keras / lunak tertentu dan efisiensi algoritmik mereka akhirnya diuji menggunakan kode yang sebenarnya.Untuk solusi dari sebuah masalah, efisiensi dari algoritme tertentu mungkin tidak terlalu berpengaruh (kecuali n sangat besar) tetapi bagi algoritme yang dirancang untuk kecepatan interaktif, komersial, atau penggunaan ilmiah jangka panjang ia bisa saja kritikal.Meningkatkan n dari kecil ke n yang besar biasanya menunjukan ketak efisienan algoritme yang tidak berbahaya.Pengujian empiris berguna karena bisa membuka interaksi tak terduga yang mempengaruhi performa.Benchmark bisa digunakan untuk membandingkan potensi kenaikan sebelum/sesudah algoritme setelah optimisasi program dilakukan.Untuk menggambarkan kemungkinan potensi peningkatan bahkan pada algoritme yang sudah teruji, inovasi terbaru, berkaitan dengan algoritme FFT (banyak digunakan di bidang pemrosesan gambar), bisa menurunkan waktu pemrosesan dengan faktor sampai 1.000 untuk aplikasi seperti pencitraan medis.[54]Secara umum, peningkatan kecepatan bergantung pada properti khusus dari permasalahan, yang mana sangat umum pada aplikasi praktis.[55]Percepatan dengan tingkat seperti itu membolehkan perangkat komputasi yang sering menggunakan pemrosesan gambar (seperti kamera digital dan peralatan medis) menghabiskan daya yang lebih sedikit.Salah satu cara mengklasifikasikan algoritme yaitu dengan cara implementasi.Cara lain mengklasifikasikan algoritme adalah dengan metodologi rancangannya atau paradigma.Ada sejumlah paradigma, tiap-tiapnya berbeda dari yang lain.Lebih lanjut, setiap kategori tersebut mengikutkan banyak tipe algoritme yang berbeda.Beberapa paradigma umum termasuk:Setiap bidang sains memiliki permasalahannya sendiri dan membutuhkan algoritme yang efisien. Masalah yang berkaitan di satu bidang terkadang dipelajari bersama. Beberapa contoh yaitu algoritme pencarian, algoritme penggabungan, algoritme numerik, algoritme grafik, algoritme deret, algoritme komputasi geometri, algoritme kombinatorial, algoritmas medis, mesin belajar, kriptografi, algoritme kompresi data dan teknik penguraian.Terkadang bidang-bidang tersebut saling tumpang tindih, dan perkembangan algoritme di satu bidang bisa meningkatkan bidang lainnya yang terkadang tidak berkaitan. Sebagai contohnya, pemrograman dinamis ditemukan untuk optimisasi konsumsi sumber daya dalam industri, tetapi sekarang digunakan untuk menyelesaikan sejumlah besar permasalahan dalam banyak bidang.Algoritme bisa diklasifikasikan berdasarkan jumlah waktu yang dibutuhkan untuk selesai dibandingkan dengan ukuran inputnya. Ada berbagai varietas: beberapa algoritme selesai dalam waktu linear relatif terhadap ukuran input, beberapa selesai dalam jumlah waktu yang eksponensial atau lebih buruh, dan beberapa berhenti. Sebagai tambahan, beberapa masalah bisa memiliki berbagai algoritme dengan kompleksitas yang berbeda, sementara permasalahan yang lain bisa saja tidak memiliki algoritme atau tidak diketahui algoritmanya yang efisien. Ada juga pemetaan dari beberapa algoritme terhadap permasalahan lain. Karena itu, lebih cocok untuk mengklasifikasikan permasalahan itu sendiri bukannya algoritme menjadi kelas-kelas yang sama berdasarkan kompleksitas dari kemungkinan algoritme terbaik baginya.Burgin (2005, p.??24) menggunakan definisi algoritme secara umum yang melonggarkan kebutuhan bersama yang keluaran dari algoritme yang menjalankan sebuah fungsi harus ditentukan setelah sejumlah langkah. Dia mendefinisikan kelas super-rekursif dari algoritme sebagai ""sebuah kelas algoritme yang mana memungkinkan untuk menghitung fungsi yang tidak bisa dihitung oleh mesin Turing manapun"" (Burgin 2005, p.??107). Hal ini berkaitan dekat dengan kajian dari metode hiperkomputasi.Untuk menjaga keseimbangan saat mengintegrasikan mesin ke dalam masyarakat, seseorang bisa mengklasifikasikan algoritme berdasarkan tipe dari evaluasi yang mereka lakukan.Sejumlah filsuf telah berhipotesis bahwa masyarakat diuntungkan dari keragaman evaluatif seperti mereka diuntungkan keragaman jender dan tipe darah (misalnya, Dean 2012, Sober & Wilson 1998) Hertzke & McConkey 1998, dan Bellah 1985).Teknologi dapat mengancam ekosistem moral tersebut seperi spesies invasif jika ia mengganggu campuran keragaman.Wallach & Allen (2008) mengklasifikasikan algoritme pembuat-keputusan menjadi tiga tipe evaluatif: Algoritme bottom-up membuat penilaian tidak terprediksi bagi pemrogram (misalnya, perangkat lunak yang berevolusi).Yang lainnya (top-down) dibagi menjadi deontologikal (yang dapat bergantung pada implementasi aturan pemrograman) lawan consequensialis (yang mengandalkan pada memaksimalkan perkiraan pemrograman).Sebagai contohnya, sebuah kalkulator standar termasuk deontologikal, sementara mesin pembelajaran untuk perdagangan saham termasuk consequensialis.Santos-Lang mengganti nama deontologikal dan consequensialis menjadi kelas ""institusional"" dan ""negosiator"" dengan tujuan untuk menghindari implikasi bahwa semua teori-teori etika deontologikal dan consequensialis bisa diimplementasikan sebagai algoritme, dan membagi kelas bottom-up menjadi ""pengganggu"" (algoritme yang tidak terprediksi karena menggunakan generator pengacakan) lawan ""relasional"" (algoritme yang tidak terprediksi karena efek jaringan).Seorang mutator dalam komputasi evolusioner bisa menjadi contoh dari pengganggu, sementara kelas 3 atau 4 dari otomata sellular adalah contoh dari mesin relasional.Santos-Lang mencatat bahwa algoritme terkadang memiliki subkomponen dari tipe lainnya.Sebagai contohnya, negosiator perdagangan saham bisa mengimplementasikan sebuah algoritme genetik, dan memiliki mutator pengganggu, dan mutator bisa memiliki subkomponen institusional dan relasional, semua komputasi adalah relasional pada tingkat di jajaran kimiawi (Santos-Lang 2014).Kata sifat ""berkelanjutan"" bila diterapkan pada kata ""algoritme"" bisa berarti:[60]Algoritme biasanya tidak dipatenkan. Di Amerika Serikat, sebuah klaim yang terdiri hanya dari manipulasi sederhana dari konsep abstrak, angka, atau sinyal tidak berarti suatu ""process"" (SPTO 2006), dan oleh karena itu algoritme tidak bisa dipatenkan (sebagaimana dalam Gottschalk v. Benson).Namun, penerapan praktis dari algoritme terkadang dipatenkan.Sebagai contohnya, dalam Diamond v. Diehr, aplikasi dari algoritme umpan-balik sederhana untuk membantu dalam menyembuhkan karet sintetis dianggap dapat dipatenkan.Mematenkan perangkat lunak sangat kontroversial, dan ada paten yang mengikutkan algoritme yang sangat dikritisi, terutama algoritme kompresi data, seperti Format Grafiknya Unisys.Sebagai tambahan, beberapa algoritme kriptografi memiliki batasan ekspor (lihat ekspor dari kriptografi).Kata ""Algoritme"", atau ""Algorisma"" pada versi penulisan lain, datang dari nama al-Khwarizmi. dieja dalam Arab klasik sebagai Al-Khwarithmi. Al-khwarizmi (bahasa Persia: ??????????????, 780-850) adalah matematikawan, ahli astronomi, ahli geografi dari Persia dan sarjana House of Wisdom di Baghdad, yang arti namanya ""penduduk asli Khwarezm"", sebuah kota yang merupakan bagian dari Wilayah Iran pada masanya dan sekarang Uzbekistan.[11][12]Sekitar tahun 825, dia menulis risalah dalam bahasa Arab, yang diterjemahkan dalam Latin pada abad ke-12 dengan judul Algoritmi de numero Indorum.Judul ini artinya ""Algoritmi pada bilangan India"", di mana ""Algoritmi"" adalah pelatinan penerjemah dari nama Al-Khwarizmi.[61]Al-Khwarizmi dulunya adalah matematikawan yang paling banyak dibaca di Eropa pada akhir Abad Pertengahan, pada umum lewat bukunya yang lain, Aljabar.[62]Pada akhir abad pertengahan, algorismus, perubahan dari namanya, berarti ""sistem bilangan desimal"" yang masih merupakan arti dari kata Inggris modern algorism.Pada abad ke-17 Prancis kata tersebut berubah, tetapi tidak maknanya, menjadi algorithme.Inggris mengadopsi Prancis setelahnya, tetapi tidak pada akhir abad ke-19 lah ""Algorithm"" mengambil makna dari kata Inggris masa sekarang.[63]Etimologi alternatif mengklaim asal mulanya dari istilah algebra (aljabar) dari makna abad pertengahan ""aritmetika Arab"" dan arithmos istilah Yunani untuk angka (yang secara harfiah berarti ""bilangan Arab"" atau ""perhitungan Arab"").Karya algoritme Al-Kharizmi bukan berbentuk seperti pada masa modern sekarang tetapi sebagai tipe dari pengulangan kalkulus (disini disebutkan bahwa karya fundamentalnya yang dikenal sebagai algebra pada awalnya berjudul ""Buku Ringkasan tentang Kalkulasi dengan Penyempurnaan dan Pengimbangan"" menjelaskan tipe-tipe dari pengulangan perhitungan dan persamaan kuadrat).Dalam makna tersebut, algoritima dikenal di Eropa jauh sebelum Al-Kharizmi.Algoritme paling tua yang dikenal sekarang adalah Algoritme Euklid (lihat juga Pengembangan algoritme Euklid).Sebelum ditemukan istilah algorithm orang Yunani menyebutnya anthyphairesis secara harfiah berarti anti-substraksi atau substraksi timbal-balik (untuk bacaan lebih lanjut disini dan ini.Algoritme dikenal oleh orang Yunani berabad sebelum[64]Euclid.Bukannya kata algebra orang Yunani menggunakan istilah arithmetica(?????????????????????, yaitu dalam karya Diophantus yang dikenal ""bapak dari Aljabar"" - lihat juga artikel Wikipedia persamaan "
2,https://id.wikipedia.org/wiki/Energi_terbarukan,"BiofuelBiomassaPanas bumiEnergi airEnergi suryaEnergi pasang surutEnergi ombakEnergi anginEnergi terbarukan energi yang berasal dari ""proses alam yang berkelanjutan"", seperti tenaga surya, tenaga angin, arus air proses biologi, dan panas bumi.Untuk mengetahui lebih lanjut tentang penggunaan energi terbarukan di masyarakat modern, lihat pengembangan energi terbarukan. Untuk diskusi umum, lihat pengembangan energi masa depan.Konsep energi terbarukan mulai dikenal pada tahun 1970-an, sebagai upaya untuk mengimbangi pengembangan energi berbahan bakar nuklir dan fosil. Definisi paling umum adalah sumber energi yang dapat dengan cepat dipulihkan kembali secara alami, dan prosesnya berkelanjutan. Dengan definisi ini, maka bahan bakar nuklir dan fosil tidak termasuk di dalamnya.Dari definisinya, semua energi terbarukan sudah pasti juga merupakan energi berkelanjutan, karena senantiasa tersedia di alam dalam waktu yang relatif sangat panjang sehingga tidak perlu khawatir atau antisipasi akan kehabisan sumbernya. Para pengusung energi non-nuklir tidak memasukkan tenaga nuklir sebagai bagian energi berkelanjutan karena persediaan uranium-235 di alam ada batasnya, katakanlah ratusan tahun. Tetapi, para penggiat nuklir berargumentasi bahwa nuklir termasuk energi berkelanjutan jika digunakan sebagai bahan bakar di reaktor pembiak cepat (FBR: Fast Breeder Reactor) karena cadangan bahan bakar nuklir bisa ""beranak"" ratusan hingga ribuan kali lipat.Alasannya begini, cadangan nuklir yang dibicarakan para pakar energi dalam ordo puluhan atau ratusan tahun itu secara implisit dihitung dengan asumsi reaktor yang digunakan adalah reaktor biasa (umumnya tipe BWR atau PWR), yang notabene hanya bisa membakar U-235. Di satu sisi kandungan U-235 di alam tak lebih dari 0,72% saja, sisanya kurang lebih 99,28% merupakan U-238. Uranium jenis U-238 ini dalam kondisi pembakaran ""biasa"" (digunakan sebagai bahan bakar di reaktor biasa) tidak dapat menghasilkan energi nuklir, tetapi jika dicampur dengan U-235 dan dimasukan bersama-sama ke dalam reaktor pembiak, bersamaan dengan konsumsi/pembakaran U-235, U-238 mengalami reaksi penangkapan 1 neutron dan berubah wujud menjadi U-239. Dalam hitungan menit U-239 meluruh sambil mengeluarkan partikel beta dan kembali berubah wujud menjadi Np-239. Np-239 juga kembali meluruh sambil memancarkan partikel beta menjadi Pu-239. Pu-239 inilah, yang meski tidak tersedia di alam tetapi terbentuk sebagai hasil sampingan pembakaran U-235, memiliki kemampuan membelah diri dan menghasilkan energi sebagaimana U-235. Bisa dibayangkan jika semua U-238 yang jumlahnya ribuan kali lebih banyak daripada U-235, berhasil diubah menjadi Pu-239, berapa peningkatan terjadi jumlah bahan bakar nuklir. Hal yang serupa juga terjadi untuk atom [thorium-233] yang dengan reaksi penangkapan 1 neutron berubah wujud menjadi U-233 yang memiliki kemampuan reaksi berantai (reaksi nuklir).Itulah sebabnya mengapa negara-negara maju tertentu enggan meninggalkan nuklir meski risiko radioaktif yang diterimanya tidak ringan. Reaktor pembiak cepat seperti yang dimiliki oleh Korea Utara mendapat pengawasan ketat dari IAEA karena mampu memproduksi bahan bakar baru Pu-239 yang rentan disalahgunakan untuk senjata pemusnah massal.Di sisi lain para penentang nuklir cenderung menggunakan istilah ""energi berkelanjutan"" sebagai sinonim dari ""energi terbarukan"" untuk mengeluarkan energi nuklir dari pembahasan kelompok energi tersebut[butuh rujukan].Energi panas bumi berasal dari peluruhan radioaktif di pusat Bumi, yang membuat Bumi panas dari dalam, serta dari panas matahari yang membuat panas permukaan bumi. Ada tiga cara pemanfaatan panas bumi:Panas bumi adalah suatu bentuk energi panas atau energi termal yang dihasilkan dan disimpan di dalam bumi. Energi panas adalah energi yang menentukan temperatur suatu benda. Energi panas bumi berasal dari energi hasil pembentukan planet (20%) dan peluruhan radioaktif dari mineral (80%)[1]. Gradien panas bumi, yang didefinisikan dengan perbedaan temperatur antara inti bumi dan permukaannya, mengendalikan konduksi yang terus menerus terjadi dalam bentuk energi panas dari inti ke permukaan bumi.Temperatur inti bumi mencapai lebih dari 5000 oC. Panas mengalir secara konduksi menuju bebatuan sekitar inti bumi. Panas ini menyebabkan bebatuan tersebut meleleh, membentuk magma. Magma mengalirkan panas secara konveksi dan bergerak naik karena magma yang berupa bebatuan cair memiliki massa jenis yang lebih rendah dari bebatuan padat. Magma memanaskan kerak bumi dan air yang mengalir di dalam kerak bumi, memanaskannya hingga mencapai 300 oC. Air yang panas ini menimbulkan tekanan tinggi sehingga air keluar dari kerak bumi[2].Energi panas bumi dari inti Bumi lebih dekat ke permukaan di beberapa daerah. Uap panas atau air bawah tanah dapat dimanfaatkan, dibawa ke permukaan, dan dapat digunakan untuk membangkitkan listrik. Sumber tenaga panas bumi berada di beberapa bagian yang tidak stabil secara geologis seperti Islandia, Selandia Baru, Amerika Serikat, Filipina, dan Italia. Dua wilayah yang paling menonjol selama ini di Amerika Serikat berada di kubah Yellowstone dan di utara California. Islandia menghasilkan tenaga panas bumi dan mengalirkan energi ke 66% dari semua rumah yang ada di Islandia pada tahun 2000, dalam bentuk energi panas secara langsung dan energi listrik melalui pembangkit listrik. 86% rumah yang ada di Islandia memanfaatkan panas bumi sebagai pemanas rumah[3][4].Karena kebanyakan energi terbaharui berasal adalah ""energi surya"" istilah ini sedikit membingungkan. Namun yang dimaksud di sini adalah energi yang dikumpulkan secara langsung dari cahaya matahari.Tenaga surya dapat digunakan untuk:Tentu saja matahari tidak memberikan energi yang konstan untuk setiap titik di bumi, sehingga penggunaannya terbatas. Sel surya sering digunakan untuk mengisi daya baterai, di siang hari dan daya dari baterai tersebut digunakan di malam hari ketika cahaya matahari tidak tersedia.Perbedaan temperatur di dua tempat yang berbeda menghasilkan tekanan udara yang berbeda, sehingga menghasilkan angin. Angin adalah gerakan materi (udara) dan telah diketahui sejak lama mampu menggerakkan turbin. Turbin angin dimanfaatkan untuk menghasilkan energi kinetik maupun energi listrik. Energi yang tersedia dari angin adalah fungsi dari kecepatan angin; ketika kecepatan angin meningkat, maka energi keluarannya juga meningkat hingga ke batas maksimum energi yang mampu dihasilkan turbin tersebut[5]. Wilayah dengan angin yang lebih kuat dan konstan seperti lepas pantai dan dataran tinggi, biasanya diutamakan untuk dibangun ""ladang angin"".Energi air digunakan karena memiliki massa dan mampu mengalir. Air memiliki massa jenis 800 kali dibandingkan udara. Bahkan gerakan air yang lambat mampu diubah ke dalam bentuk energi lain. Turbin air didesain untuk mendapatkan energi dari berbagai jenis reservoir, yang diperhitungkan dari jumlah massa air, ketinggian, hingga kecepatan air. Energi air dimanfaatkan dalam bentuk:Tumbuhan biasanya menggunakan fotosintesis untuk menyimpan tenaga surya, udara, dan CO2. Bahan bakar bio (biofuel) adalah bahan bakar yang diperoleh dari biomassa - organisme atau produk dari metabolisme hewan, seperti kotoran dari sapi dan sebagainya. Ini juga merupakan salah satu sumber energi terbaharui. Biasanya biomass dibakar untuk melepas energi kimia yang tersimpan di dalamnya, pengecualian ketika biofuel digunakan untuk bahan bakar fuel cell (misal direct methanol fuel cell dan direct ethanol fuel cell).Biomassa dapat digunakan langsung sebagai bahan bakar atau untuk memproduksi bahan bakar jenis lain seperti biodiesel, bioetanol, atau biogas tergantung sumbernya. Biomassa berbentuk biodiesel, bioetanol, dan biogas dapat dibakar dalam mesin pembakaran dalam atau pendidih secara langsung dengan kondisi tertentu.Biomassa menjadi sumber energi terbarukan jika laju pengambilan tidak melebihi laju produksinya, karena pada dasarnya biomassa merupakan bahan yang diproduksi oleh alam dalam waktu relatif singkat melalui berbagai proses biologis. Berbagai kasus penggunaan biomassa yang tidak terbarukan sudah terjadi, seperti kasus deforestasi zaman romawi, dan yang sekarang terjadi, deforestasi hutan amazon. Gambut juga sebenarnya biomassa yang pendefinisiannya sebagai energi terbarukan cukup bias karena laju ekstraksi oleh manusia tidak sebanding dengan laju pertumbuhan lapisan gambut[6][7].Ada tiga bentuk penggunaan biomassa, yaitu secara padat, cair, dan gas [8]. Dan secara umum ada dua metode dalam memproduksi biomassa, yaitu dengan menumbuhkan organisme penghasil biomassa dan menggunakan bahan sisa hasil industri pengolahan makhluk hidup.Bahan bakar bio cair biasanya berbentuk bioalkohol seperti metanol, etanol dan biodiesel. Biodiesel dapat digunakan pada kendaraan diesel modern dengan sedikit atau tanpa modifikasi dan dapat diperoleh dari limbah sayur dan minyak hewani serta lemak. Tergantung potensi setiap daerah, jagung, gula bit, tebu, dan beberapa jenis rumput dibudidayakan untuk menghasilkan bioetanol. Sedangkan biodiesel dihasilkan dari tanaman atau hasil tanaman yang mengandung minyak (kelapa sawit, kopra, biji jarak, alga) dan telah melalui berbagai proses seperti esterifikasi.Penggunaan langsung biasanya dalam bentuk padatan yang mudah terbakar, baik kayu bakar atau tanaman yang mudah terbakar. Tanaman dapat dibudidayakan secara khusus untuk pembakaran atau dapat digunakan untuk keperluan lain, seperti diolah di industri tertentu dan limbah hasil pengolahan yang bisa dibakar dijadikan bahan bakar. Pembuatan briket biomassa juga menggunakan biomassa padat, di mana bahan bakunya bisa berupa potongan atau serpihan biomassa padat mentah atau yang telah melalui proses tertentu seperti pirolisis untuk meningkatkan persentase karbon dan mengurangi kadar airnya.Biomassa padat juga bisa diolah dengan cara gasifikasi untuk menghasilkan gas.Berbagai bahan organik, secara biologis dengan fermentasi, maupun secara fisiko-kimia dengan gasifikasi, dapat melepaskan gas yang mudah terbakar.Biogas dapat dengan mudah dihasilkan dari berbagai limbah dari industri yang ada saat ini, seperti produksi kertas, produksi gula, kotoran hewan peternakan, dan sebagainya. Berbagai aliran limbah harus diencerkan dengan air dan dibiarkan secara alami berfermentasi, menghasilkan gas metana. Residu dari aktivitas fermentasi ini adalah pupuk yang kaya nitrogen, karbon, dan mineral.Beberapa orang tidak menyukai estetika turbin angin atau mengemukakan isu-isu konservasi alam ketika panel surya besar dipasang di pedesaan. Pihak yang mencoba memanfaatkan teknologi terbarukan ini harus melakukannya dengan cara yang disukai, misal memanfaatkan kolektor surya sebagai penghalang kebisingan sepanjang jalan, memadukannya sebagai peneduh matahari, memasangnya di atap yang sudah tersedia dan bahkan bisa menggantikan atap sepenuhnya, juga sel fotovoltaik amorf dapat digunakan untuk menggantikan jendela.Beberapa sistem ekstrasi energi terbarukan menghasilkan masalah lingkungan yang unik. Misalnya, turbin angin bisa berbahaya untuk burung yang terbang, sedangkan bendungan air pembangkit listrik dapat menciptakan penghalang bagi migrasi ikan - masalah serius di bagian barat laut pasifik yang telah mengurangi populasi ikan salmon. Pembakaran biomassa dan biofuel menyebabkan polusi udara yang sama dengan membakar bahan bakar fosil, meskipun karbon yang dilepaskan ke atmosfer ini dapat diserap kembali jika organisme penghasil biomassa tersebut secara terus menerus dibudidayakan.Masalah lain dengan banyak energi terbarukan, khususnya biomassa dan biofuel, adalah sejumlah besar lahan yang dibutuhkan untuk usaha pembudidayaannya.Masalah lain adalah variabilitas dan persebaran energi terbarukan di alam, kecuali energi panas bumi yang umumnya terkonsentrasi pada satu wilayah tertentu namun terdapat pada lokasi yang ekstrem. Energi angin adalah yang tersulit untuk difokuskan, sehingga membutuhkan turbin yang besar untuk menangkap energi angin sebanyak-banyaknya. Metode pemanfaatan energi air bergantung pada lokasi dan karakteristik sumber air sehingga desain turbin air bisa berbeda. Pemanfaatan energi matahari dapat dilakukan dengan berbagai cara, namun untuk mendapatkan energi yang banyak membutuhkan luas area penangkapan yang besar.Sebagai perbandingan, pada kondisi standar pengujian di Amerika Serikat energi yang diterima 1 m2 sel surya yang memiliki efisiensi 20% akan menghasilkan 200 watt. Kondisi standar pengujian yang dimaksud adalah temperatur udara 20 oC dan irradiansi 1000 W/m2[14][15].Keragaman geografis juga menjadi masalah signifikan, karena beberapa sumber energi terbarukan seperti panas bumi, air, dan angin bisa berada di lokasi yang jauh dari penerima energi listrik; panas bumi di pegunungan, energi air di hulu sungai, dan energi angin di lepas pantai atau dataran tinggi. Pemanfaatan sumber daya tersebut dalam skala besar kemungkinan akan memerlukan investasi cukup besar dalam jaringan transmisi dan distribusi serta teknologi itu sendiri dalam menghadapi lingkungan terkait.Salah satu kekurangan yang cukup signifikan adalah ketersediaan energi terbarukan di alam; beberapa dari mereka hanya ada sesekali dan tidak setiap saat (intermittent). Misal cahaya matahari yang hanya tersedia ketika siang hari, energi angin yang kekuatannya bervariasi setiap saat, energi air yang tak bisa dimanfaatkan ketika sungai kering, biomassa memiliki masalah yang sama dengan yang dihadapi dunia pertanian (misal iklim, hama), dan lain-lain. Sedangkan energi panas bumi bisa tersedia sepanjang waktu.Sepanjang sejarah, berbagai macam energi terbarukan telah digunakan."
